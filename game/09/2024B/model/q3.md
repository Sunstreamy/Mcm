### **3.2 问题三：多阶段生产决策的动态规划模型**

#### **3.2.1 问题分析与建模思想**

问题三描述了一个由多个零配件（Part）、经过多道工序（Assembly）、最终形成成品的复杂生产系统。系统中的每个生产环节都存在不确定性（次品率），并包含多个决策点（是否检测、如何处理次品）。

由于该系统具有明显的多阶段特性，且各阶段的决策会共同影响最终的系统总成本与利润，这是一个典型的**多阶段决策优化问题 (Multi-stage Decision Process)**。

直接枚举所有可能的决策组合不仅计算量巨大，且无法提供过程性的管理洞察。我们观察到，该问题满足**贝尔曼最优性原理**，即一个最优决策序列的任何子序列，对于由该子序列的起始状态所引导的子问题而言，也必然是最优的。这表明该问题具有**最优子结构 (Optimal Substructure)** 的特性，因此，采用**动态规划 (Dynamic Programming, DP)** 是解决此问题的最适宜方法。

我们将整个生产流程抽象为一个**有向无环图 (DAG)**，并在此图上进行**逆向递推求解**。

#### **3.2.2 模型关键符号定义**

为清晰阐述模型，我们首先定义以下基础参数与变量：

| 符号 | 含义 |
| :--- | :--- |
| `j` | 生产流程图中的任意一个节点 |
| `p(j)` | 零配件节点`j`的原始次品率 |
| `p_a(j)` | 装配节点`j`的工艺次品率 |
| `c_buy(j)` | 零配件节点`j`的采购单价 |
| `c_test(j)` | 节点`j`的检测成本 |
| `c_assy(j)` | 装配节点`j`的装配成本 |
| `c_dis(j)` | 装配节点`j`的拆解费用 |
| `S` | 最终成品F的市场售价 |
| `L` | 最终成品F的市场调换损失 |
| `Parents(j)` | 节点`j`的所有直接上游父节点集合 |

#### **3.2.3 动态规划模型构建**

**1. 状态变量 (State Variables)**
为精确描述系统状态，我们为每个节点 `j` 定义了两个核心状态变量，它们共同构成了该节点的“成本契约菜单”：

*   **`C_good(j)`**: 为了获得一个**确保100%合格**的节点`j`产品，所需付出的**最小期望总成本**。
*   **`C_asis(j)`**: 为了获得一个**未经本阶段检测、带有其固有次品风险**的节点`j`产品，所需付出的**最小期望总成本**。此状态伴随一个参数：
    *   **`p_asis(j)`**: 与`C_asis(j)`伴随的**有效次品率**。

**2. 状态转移方程 (State Transition Equations)**
状态转移方程是连接各阶段的数学桥梁，它定义了如何从后一阶段（子问题）的已知最优状态，推导出当前阶段的最优状态。

**A. 对于零配件节点 `k` (边界条件)**

*   **“正品契约”成本 `C_good(k)`**：
    获得合格零配件的唯一方式是检测。其成本是符合几何分布的期望成本。
    $$
    C_{good}(k) = \frac{c_{buy}(k) + c_{test}(k)}{1 - p(k)} \quad \cdots \quad (1)
    $$
*   **“原样契约”成本 `C_asis(k)`**：
    获得原样零配件的方式是不检测。
    $$
    C_{asis}(k) = c_{buy}(k) \quad \text{with} \quad p_{asis}(k) = p(k) \quad \cdots \quad (2)
    $$

**B. 对于装配节点 `j` (递推步骤)**

*   **计算 `C_asis(j)` (提供“原样”产品)**:
    为提供“原样”产品，本阶段决策必须是“不检测”。为最小化成本，向上游所有父节点 `i ∈ Parents(j)` 发出“原样契约”订单。
    $$
    C_{asis}(j) = \left( \sum_{i \in Parents(j)} C_{asis}(i) \right) + c_{assy}(j) \quad \cdots \quad (3)
    $$
    其伴随的有效次品率 `p_asis(j)` 为：
    $$
    p_{asis}(j) = 1 - \left( (1 - p_a(j)) \cdot \prod_{i \in Parents(j)} (1 - p_{asis}(i)) \right) \quad \cdots \quad (4)
    $$

*   **计算 `C_good(j)` (提供“正品”产品)**:
    为提供“正品”，本阶段决策必须是“检测”。我们需在“检+拆解”和“检+报废”中选择成本更低的方案。为最小化风险，向上游所有父节点 `i ∈ Parents(j)` 发出“正品契约”订单。
    $$
    C_{good}(j) = \min \left( C_{scrap}(j), C_{salvage}(j) \right) \quad \cdots \quad (5)
    $$
    其中：
    *   **`C_scrap(j)`**:
        $$
        C_{scrap}(j) = \frac{(\sum_{i \in Parents(j)} C_{good}(i)) + c_{assy}(j) + c_{test}(j)}{1 - p_a(j)} \quad \cdots \quad (6)
        $$
        *<center>解释：此为“检测后报废”策略的期望成本。因上游物料100%合格，失败仅源于本阶段工艺，每次失败损失所有投入。</center>*
    *   **`C_salvage(j)`**:
        $$
        C_{salvage}(j) = \frac{(\sum_{i \in Parents(j)} C_{good}(i)) + c_{assy}(j) + c_{test}(j) - p_a(j) \cdot ((\sum_{i \in Parents(j)} C_{good}(i)) - c_{dis}(j))}{1 - p_a(j)} \quad \cdots \quad (7)
        $$
        *<center>解释：此为“检测后拆解”策略的期望成本。每次失败可通过拆解回收上游物料价值，仅损失装配、检测及拆解费用。</center>*

#### **3.2.4 全局最优策略求解**

DP的逆向递推为每个节点生成了“成本菜单”。最终的全局最优解需在根节点（成品`F`）进行顶层决策，通过比较所有可能全局策略的期望利润 `E[Profit]` 来确定。

为简化表达，我们先定义最终成品F的四种不同策略下的**单件合格品期望总成本**。

**1. 策略`σ_1`：成品检+拆解**
此策略下，单件合格品的成本即为 `C_salvage(F)`。
$$
E[\text{Cost} | \sigma_1] = C_{salvage}(F) \quad \cdots \quad (8)
$$

**2. 策略`σ_2`：成品检+报废**
此策略下，单件合格品的成本即为 `C_scrap(F)`。
$$
E[\text{Cost} | \sigma_2] = C_{scrap}(F) \quad \cdots \quad (9)
$$

**3. 策略`σ_3`：成品不检+退货拆解**
此策略将带有次品风险的产品投入市场，通过售后服务保证最终交付给消费者的都是合格品。
$$
E[\text{Cost} | \sigma_3] = \frac{C_{asis}(F) + p_{asis}(F) \cdot (L + c_{dis}(F) - \sum_{i \in Parents(F)} C_{asis}(i))}{1 - p_{asis}(F)} \quad \cdots \quad (10)
$$
*<center>解释：成本由基础生产成本`C_asis(F)`和市场失效率`p_asis(F)`引发的额外损失构成，最终分摊到`1-p_asis(F)`的合格品上。</center>*

**4. 策略`σ_4`：成品不检+退货报废**
$$
E[\text{Cost} | \sigma_4] = \frac{C_{asis}(F) + p_{asis}(F) \cdot (L + C_{asis}(F))}{1 - p_{asis}(F)} \quad \cdots \quad (11)
$$
*<center>解释：与策略3类似，但退回的次品直接报废，损失其全部`C_asis(F)`价值。</center>*

**全局最优利润 `E[Profit]*`** 通过比较四种策略的利润得出：
$$
E[\text{Profit}]^* = S - \min(E[\text{Cost} | \sigma_1], E[\text{Cost} | \sigma_2], E[\text{Cost} | \sigma_3], E[\text{Cost} | \sigma_4]) \quad \cdots \quad (12)
$$

确定了利润最高的顶层策略后，即可确定对根节点的契约要求（“good”或“asis”）。然后从根节点开始，根据该要求以及在计算过程中各节点所做的 `min` 选择，即可反向追溯出唯一的、贯穿所有节点的全局最优策略链。